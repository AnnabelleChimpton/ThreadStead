/**
 * VISUAL_BUILDER_PROGRESS: HTML Generator
 * Phase 1: Visual Builder Foundation - Conversion Utilities
 *
 * Converts canvas state to HTML template format
 */

import type {
  CanvasState,
  CanvasComponent,
  ComponentPosition,
  ComponentSize,
  GridPosition,
  GridSystem,
} from './types';
import { componentRegistry } from '@/lib/templates/core/template-registry';
import { sortGridPositionsByVisualOrder, calculateRequiredGridArea } from './grid-utils';

export interface HTMLGenerationOptions {
  /** Include position and size attributes for layout */
  includeLayoutAttributes?: boolean;
  /** Pretty print with indentation */
  prettyPrint?: boolean;
  /** Indentation string (default: 2 spaces) */
  indent?: string;
  /** Include comments for structure */
  includeComments?: boolean;
  /** Wrap in container div */
  wrapInContainer?: boolean;
  /** Container class name */
  containerClass?: string;
}

export interface HTMLGenerationResult {
  /** Generated HTML string */
  html: string;
  /** Any warnings or issues encountered */
  warnings: string[];
  /** Component count */
  componentCount: number;
}

/**
 * Main HTML generator class
 */
export class HTMLGenerator {
  private options: Required<HTMLGenerationOptions>;
  private warnings: string[] = [];
  private componentCount = 0;

  constructor(options: HTMLGenerationOptions = {}) {
    this.options = {
      includeLayoutAttributes: options.includeLayoutAttributes ?? true,
      prettyPrint: options.prettyPrint ?? true,
      indent: options.indent ?? '  ',
      includeComments: options.includeComments ?? false,
      wrapInContainer: options.wrapInContainer ?? false,
      containerClass: options.containerClass ?? 'visual-builder-template',
    };
  }

  /**
   * Generate HTML from canvas state
   */
  generateHTML(canvasState: CanvasState): HTMLGenerationResult {
    this.warnings = [];
    this.componentCount = 0;

    const components = canvasState.components;
    if (components.length === 0) {
      return {
        html: this.options.wrapInContainer
          ? this.wrapInContainer('<!-- Empty template -->', canvasState)
          : '<!-- Empty template -->',
        warnings: [],
        componentCount: 0,
      };
    }

    // Generate HTML for root components
    const rootComponents = components.filter(comp => !this.hasParent(comp.id, components));
    const htmlParts: string[] = [];

    if (this.options.includeComments) {
      htmlParts.push('<!-- Generated by Visual Template Builder -->');
    }

    // Sort root components by grid position if using grid layout
    const layoutMode = this.detectLayoutMode(canvasState);
    const sortedRootComponents = layoutMode === 'grid'
      ? this.sortComponentsByGridOrder(rootComponents)
      : rootComponents;

    for (const component of sortedRootComponents) {
      const componentHTML = this.generateComponentHTML(component, components, 0);
      htmlParts.push(componentHTML);
    }

    let html = htmlParts.join(this.options.prettyPrint ? '\n' : '');

    if (this.options.wrapInContainer) {
      html = this.wrapInContainer(html, canvasState);
    }

    return {
      html,
      warnings: [...this.warnings],
      componentCount: this.componentCount,
    };
  }

  /**
   * Detect the primary layout mode used by the canvas
   */
  private detectLayoutMode(canvasState: CanvasState): 'grid' | 'absolute' | 'flow' {
    const rootComponents = canvasState.components.filter(comp => !this.hasParent(comp.id, canvasState.components));

    let gridCount = 0;
    let absoluteCount = 0;

    rootComponents.forEach(comp => {
      if (comp.positioningMode === 'grid' && comp.gridPosition) {
        gridCount++;
      } else if (comp.position) {
        absoluteCount++;
      }
    });

    // If majority of root components use grid positioning, use grid layout
    if (gridCount > absoluteCount && gridCount > 0) {
      return 'grid';
    } else if (absoluteCount > 0) {
      return 'absolute';
    } else {
      return 'flow';
    }
  }

  /**
   * Sort components by their visual grid order (top-to-bottom, left-to-right)
   */
  private sortComponentsByGridOrder(components: CanvasComponent[]): CanvasComponent[] {
    return [...components].sort((a, b) => {
      // Components without grid positions go to the end
      if (!a.gridPosition && !b.gridPosition) return 0;
      if (!a.gridPosition) return 1;
      if (!b.gridPosition) return -1;

      // Sort by row first, then by column
      if (a.gridPosition.row !== b.gridPosition.row) {
        return a.gridPosition.row - b.gridPosition.row;
      }

      return a.gridPosition.column - b.gridPosition.column;
    });
  }

  /**
   * Generate HTML for a single component and its children
   */
  private generateComponentHTML(
    component: CanvasComponent,
    allComponents: CanvasComponent[],
    depth: number
  ): string {
    this.componentCount++;

    const registration = componentRegistry.get(component.type);
    if (!registration) {
      this.warnings.push(`Unknown component type: ${component.type}`);
      return this.generateComment(`Unknown component: ${component.type}`, depth);
    }

    // Get child components
    const childComponents = component.children || [];

    // Generate component attributes
    const attributes = this.generateAttributes(component);
    const attributeString = Object.entries(attributes)
      .map(([key, value]) => `${key}="${this.escapeAttribute(value)}"`)
      .join(' ');

    // Note: For now, assume no components are self-closing since the registry doesn't specify this
    // In the future, we could add a selfClosing property to ComponentRegistration or maintain a list

    // Generate opening tag
    const indent = this.options.prettyPrint ? this.getIndent(depth) : '';
    const openTag = `${indent}<${component.type}${attributeString ? ' ' + attributeString : ''}>`;

    // Generate children HTML
    const childrenHTML: string[] = [];

    // For text components, use content prop as text children
    const isTextComponent = ['TextElement', 'Heading', 'Paragraph'].includes(component.type);
    if (isTextComponent && component.props.content) {
      const textIndent = this.options.prettyPrint ? this.getIndent(depth + 1) : '';
      childrenHTML.push(`${textIndent}${this.escapeHTML(String(component.props.content))}`);
    }
    // Add any text content from props.children
    else if (component.props.children && typeof component.props.children === 'string') {
      const textIndent = this.options.prettyPrint ? this.getIndent(depth + 1) : '';
      childrenHTML.push(`${textIndent}${this.escapeHTML(component.props.children as string)}`);
    }

    // Add child components
    for (const child of childComponents) {
      const childHTML = this.generateComponentHTML(child, allComponents, depth + 1);
      childrenHTML.push(childHTML);
    }

    // Generate closing tag
    const closeTag = `${indent}</${component.type}>`;

    // Combine parts
    if (childrenHTML.length === 0) {
      // Empty component
      if (this.options.prettyPrint) {
        return `${openTag}\n${closeTag}`;
      } else {
        return `${openTag}</${component.type}>`;
      }
    } else {
      // Component with children
      if (this.options.prettyPrint) {
        return `${openTag}\n${childrenHTML.join('\n')}\n${closeTag}`;
      } else {
        return `${openTag}${childrenHTML.join('')}${closeTag}`;
      }
    }
  }

  /**
   * Generate attributes for a component
   */
  private generateAttributes(component: CanvasComponent): Record<string, string> {
    const attributes: Record<string, string> = {};

    // Check if this is a text component
    const isTextComponent = ['TextElement', 'Heading', 'Paragraph'].includes(component.type);

    // Universal CSS properties that should be preserved as attributes
    const universalCSSProperties = [
      'backgroundColor', 'color', 'textColor', 'borderColor', 'accentColor',
      'fontSize', 'fontFamily', 'fontWeight', 'textAlign', 'lineHeight',
      'padding', 'margin', 'border', 'borderRadius', 'borderWidth', 'boxShadow',
      'opacity', 'position', 'top', 'right', 'bottom', 'left', 'width', 'height',
      'minWidth', 'minHeight', 'maxWidth', 'maxHeight', 'zIndex', 'display',
      'flexDirection', 'justifyContent', 'alignItems', 'gap', 'rowGap', 'columnGap',
      'gridTemplateColumns', 'gridTemplateRows', 'customCSS'
    ];

    // Helper function to process props from either props or publicProps
    const processPropsObject = (propsObject: Record<string, any>) => {
      Object.entries(propsObject).forEach(([key, value]) => {
        // Skip special props
        if (key === 'children') return;

        // Skip content prop for text components (it becomes the element's text content)
        if (isTextComponent && key === 'content') return;

        // Convert prop value to attribute
        if (value !== undefined && value !== null) {
          if (typeof value === 'boolean') {
            if (value) {
              attributes[key] = key; // boolean attribute
            }
          } else if (typeof value === 'string') {
            attributes[key] = value;
          } else if (typeof value === 'number') {
            attributes[key] = value.toString();
          } else {
            // Complex objects - serialize as JSON
            try {
              attributes[key] = JSON.stringify(value);
            } catch (error) {
              this.warnings.push(`Failed to serialize prop ${key} for component ${component.type}`);
            }
          }
        }
      });
    };

    // Process component props (legacy structure)
    if (component.props) {
      processPropsObject(component.props);
    }

    // Process publicProps (new standardized structure) - these take precedence
    if ((component as any).publicProps) {
      processPropsObject((component as any).publicProps);
    }

    // Add layout attributes if enabled
    if (this.options.includeLayoutAttributes) {
      const styles: string[] = [];

      // Handle different positioning modes
      if (component.positioningMode === 'grid' && component.gridPosition) {
        // CSS Grid positioning
        styles.push(`grid-column: ${component.gridPosition.column} / span ${component.gridPosition.columnSpan}`);
        styles.push(`grid-row: ${component.gridPosition.row} / span ${component.gridPosition.rowSpan}`);

        // Keep data attributes for debugging/parsing
        attributes['data-grid-position'] = JSON.stringify(component.gridPosition);
        attributes['data-positioning-mode'] = 'grid';
      } else if (component.position) {
        // Legacy absolute positioning
        styles.push('position: absolute');
        styles.push(`left: ${component.position.x}px`);
        styles.push(`top: ${component.position.y}px`);

        // Keep data attributes for debugging/parsing - use consistent pixel position format
        attributes['data-pixel-position'] = JSON.stringify({
          x: component.position.x,
          y: component.position.y,
          positioning: 'absolute'
        });
        attributes['data-positioning-mode'] = 'absolute';

        // Also keep legacy format for backwards compatibility
        attributes['data-position'] = `${component.position.x},${component.position.y}`;
      }

      // Add size data attribute (avoid duplicates by consolidating size information)
      if (component.size) {
        // Only add size styles if not using absolute positioning (absolute uses data attributes instead)
        if (component.positioningMode !== 'absolute') {
          if (component.size.width && component.size.width !== 'auto') {
            styles.push(`width: ${component.size.width}px`);
          }
          if (component.size.height && component.size.height !== 'auto') {
            styles.push(`height: ${component.size.height}px`);
          }
        }

        if (component.size.minWidth) {
          styles.push(`min-width: ${component.size.minWidth}px`);
        }
        if (component.size.minHeight) {
          styles.push(`min-height: ${component.size.minHeight}px`);
        }
        if (component.size.maxWidth) {
          styles.push(`max-width: ${component.size.maxWidth}px`);
        }
        if (component.size.maxHeight) {
          styles.push(`max-height: ${component.size.maxHeight}px`);
        }

        // Always add size data attribute for parsing - this is the authoritative size source
        attributes['data-component-size'] = JSON.stringify(component.size);
      }

      // Apply styles if any were generated
      if (styles.length > 0) {
        const existingStyle = attributes['style'] || '';
        const newStyle = existingStyle
          ? `${existingStyle}; ${styles.join('; ')}`
          : styles.join('; ');
        attributes['style'] = newStyle;
      }

      // Add component state attributes
      if (component.locked) {
        attributes['data-locked'] = 'true';
      }
      if (component.hidden) {
        attributes['data-hidden'] = 'true';
      }
    }

    // Add component ID for debugging
    if (this.options.includeComments) {
      attributes['data-component-id'] = component.id;
    }

    return attributes;
  }

  /**
   * Check if component has a parent
   */
  private hasParent(componentId: string, allComponents: CanvasComponent[]): boolean {
    return allComponents.some(comp =>
      comp.children && comp.children.some(child => child.id === componentId)
    );
  }

  /**
   * Generate indentation for pretty printing
   */
  private getIndent(depth: number): string {
    return this.options.indent.repeat(depth);
  }

  /**
   * Generate comment HTML
   */
  private generateComment(text: string, depth: number): string {
    const indent = this.options.prettyPrint ? this.getIndent(depth) : '';
    return `${indent}<!-- ${text} -->`;
  }

  /**
   * Wrap HTML in container
   */
  private wrapInContainer(html: string, canvasState: CanvasState): string {
    if (!this.options.includeLayoutAttributes) {
      const openTag = `<div class="${this.options.containerClass}">`;
      const closeTag = '</div>';

      if (this.options.prettyPrint) {
        const indentedHTML = html
          .split('\n')
          .map(line => line.trim() ? this.options.indent + line : line)
          .join('\n');
        return `${openTag}\n${indentedHTML}\n${closeTag}`;
      } else {
        return `${openTag}${html}${closeTag}`;
      }
    }

    // Determine container style based on layout mode
    const layoutMode = this.detectLayoutMode(canvasState);
    const containerStyles: string[] = [];

    // Use consistent class naming for grid containers that matches profile renderer
    let containerClass = this.options.containerClass;

    if (layoutMode === 'grid') {
      // CSS Grid container - align with profile renderer class naming
      containerClass = 'advanced-template-container grid-enabled';
      const gridComponents = canvasState.components.filter(comp =>
        comp.positioningMode === 'grid' && comp.gridPosition
      );

      if (gridComponents.length > 0) {
        // Calculate required grid dimensions
        const gridPositions = gridComponents.map(comp => comp.gridPosition!);
        const { minColumns, minRows } = calculateRequiredGridArea(gridPositions);

        containerStyles.push('display: grid');
        containerStyles.push(`grid-template-columns: repeat(${Math.max(minColumns, canvasState.settings.gridSystem.columns)}, 1fr)`);
        containerStyles.push(`grid-auto-rows: ${canvasState.settings.gridSystem.cellSize.height}px`);
        containerStyles.push(`gap: ${canvasState.settings.gridSystem.gap}px`);
        containerStyles.push('width: 100%');
        containerStyles.push('max-width: 100vw');
        containerStyles.push('min-height: 100vh');
        containerStyles.push(`padding: ${canvasState.settings.gridSystem.gap * 2}px`);
        containerStyles.push('box-sizing: border-box');
      } else {
        // Fallback for grid mode with no grid components
        containerStyles.push('position: relative');
        containerStyles.push('min-height: 400px');
      }
    } else {
      // Absolute positioning container - use template-container class for backwards compatibility
      containerClass = 'template-container';
      containerStyles.push('position: relative');
      containerStyles.push('min-height: 400px');
    }

    const containerStyle = containerStyles.join('; ');
    const openTag = `<div class="${containerClass}" style="${containerStyle}">`;
    const closeTag = '</div>';

    if (this.options.prettyPrint) {
      const indentedHTML = html
        .split('\n')
        .map(line => line.trim() ? this.options.indent + line : line)
        .join('\n');
      return `${openTag}\n${indentedHTML}\n${closeTag}`;
    } else {
      return `${openTag}${html}${closeTag}`;
    }
  }

  /**
   * Escape HTML content
   */
  private escapeHTML(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  /**
   * Escape attribute values
   */
  private escapeAttribute(value: string): string {
    return value
      .replace(/&/g, '&amp;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }
}

/**
 * Convenience function to generate HTML from canvas state
 */
export function generateHTMLFromCanvas(
  canvasState: CanvasState,
  options?: HTMLGenerationOptions
): HTMLGenerationResult {
  const generator = new HTMLGenerator(options);
  return generator.generateHTML(canvasState);
}

/**
 * Generate HTML optimized for template engine
 */
export function generateTemplateHTML(canvasState: CanvasState): HTMLGenerationResult {
  return generateHTMLFromCanvas(canvasState, {
    includeLayoutAttributes: true, // Include positioning for template preservation
    prettyPrint: true,
    includeComments: false,
    wrapInContainer: true, // Wrap in positioned container
    containerClass: 'visual-builder-canvas',
  });
}

/**
 * Generate HTML with debugging information
 */
export function generateDebugHTML(canvasState: CanvasState): HTMLGenerationResult {
  return generateHTMLFromCanvas(canvasState, {
    includeLayoutAttributes: true,
    prettyPrint: true,
    includeComments: true,
    wrapInContainer: true,
    containerClass: 'visual-builder-debug',
  });
}

/**
 * Generate compact HTML for storage/transmission
 */
export function generateCompactHTML(canvasState: CanvasState): HTMLGenerationResult {
  return generateHTMLFromCanvas(canvasState, {
    includeLayoutAttributes: false,
    prettyPrint: false,
    includeComments: false,
    wrapInContainer: false,
  });
}

/**
 * Validate canvas state before HTML generation
 */
export function validateCanvasForGeneration(canvasState: CanvasState): {
  isValid: boolean;
  errors: string[];
  warnings: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Check for orphaned components
  const allComponentIds = new Set(canvasState.components.map(c => c.id));

  function checkComponentTree(components: CanvasComponent[], parentId?: string) {
    components.forEach(component => {
      if (component.children) {
        component.children.forEach(child => {
          // All children should be valid components
          if (!allComponentIds.has(child.id)) {
            errors.push(`Component ${component.id} references non-existent child: ${child.id}`);
          }
        });
        checkComponentTree(component.children, component.id);
      }
    });
  }

  checkComponentTree(canvasState.components);

  // Check for circular references
  const visited = new Set<string>();
  const inStack = new Set<string>();

  function hasCycle(componentId: string): boolean {
    if (inStack.has(componentId)) return true;
    if (visited.has(componentId)) return false;

    visited.add(componentId);
    inStack.add(componentId);

    const component = canvasState.components.find(c => c.id === componentId);
    if (component?.children) {
      for (const child of component.children) {
        if (hasCycle(child.id)) return true;
      }
    }

    inStack.delete(componentId);
    return false;
  }

  for (const component of canvasState.components) {
    if (hasCycle(component.id)) {
      errors.push(`Circular reference detected starting from component: ${component.id}`);
      break;
    }
  }

  // Check for unknown component types
  canvasState.components.forEach(component => {
    if (!componentRegistry.get(component.type)) {
      warnings.push(`Unknown component type: ${component.type}`);
    }
  });

  return {
    isValid: errors.length === 0,
    errors,
    warnings,
  };
}