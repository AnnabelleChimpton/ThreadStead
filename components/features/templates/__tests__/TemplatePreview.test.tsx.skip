import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import TemplatePreview from '../TemplatePreview';
import { createMockResidentData } from '../../../lib/templates/__tests__/test-utils';

// Mock the shadow DOM functionality
const mockShadowRoot = {
  appendChild: jest.fn(),
  querySelector: jest.fn(),
  insertBefore: jest.fn()
};

const mockAttachShadow = jest.fn(() => mockShadowRoot);

beforeEach(() => {
  // Mock shadow DOM support
  Object.defineProperty(HTMLDivElement.prototype, 'attachShadow', {
    value: mockAttachShadow,
    writable: true
  });

  // Mock document.createElement for shadow DOM container
  const originalCreateElement = document.createElement;
  document.createElement = jest.fn((tagName) => {
    if (tagName === 'div' || tagName === 'style') {
      const element = originalCreateElement.call(document, tagName);
      if (tagName === 'div') {
        element.id = 'shadow-content';
        element.className = 'site-layout';
      }
      return element;
    }
    return originalCreateElement.call(document, tagName);
  });
});

afterEach(() => {
  jest.clearAllMocks();
});

describe.skip('TemplatePreview (crypto dependency limitation)', () => {
  const mockUser = {
    id: 'test-user-123',
    primaryHandle: 'testuser',
    profile: {
      displayName: 'Test User',
      bio: 'Test bio',
      avatarUrl: '/test-avatar.jpg'
    },
    handles: [{ handle: 'testuser@test.com' }]
  };

  const defaultProps = {
    user: mockUser,
    template: '',
    customCSS: '',
    cssMode: 'inherit' as const,
    renderMode: 'islands' as const,
    residentData: createMockResidentData()
  };

  describe('Basic Rendering', () => {
    it('should render empty state when no template provided', async () => {
      render(<TemplatePreview {...defaultProps} />);
      
      await waitFor(() => {
        expect(screen.getByText('Enter a template to see the preview')).toBeInTheDocument();
      });
    });

    it('should show compilation status when compiling', async () => {
      const propsWithTemplate = {
        ...defaultProps,
        template: '<ProfilePhoto size="large" />'
      };

      render(<TemplatePreview {...propsWithTemplate} />);
      
      // Should briefly show compilation status
      await waitFor(() => {
        expect(screen.queryByText('ðŸ”„ Compiling template...')).toBeInTheDocument();
      }, { timeout: 100 });
    });

    it('should initialize shadow DOM for islands preview', async () => {
      const propsWithTemplate = {
        ...defaultProps,
        template: '<ProfilePhoto />'
      };

      render(<TemplatePreview {...propsWithTemplate} />);
      
      await waitFor(() => {
        expect(mockAttachShadow).toHaveBeenCalledWith({ mode: 'open' });
      });
    });
  });

  describe('Template Compilation', () => {
    it('should compile simple template successfully', async () => {
      const onCompile = jest.fn();
      const propsWithTemplate = {
        ...defaultProps,
        template: '<ProfilePhoto />',
        onCompile
      };

      render(<TemplatePreview {...propsWithTemplate} />);
      
      await waitFor(() => {
        expect(onCompile).toHaveBeenCalledWith(
          expect.objectContaining({
            mode: 'advanced',
            staticHTML: expect.any(String),
            islands: expect.any(Array)
          })
        );
      }, { timeout: 1000 });
    });

    it('should handle compilation errors gracefully', async () => {
      const onError = jest.fn();
      const propsWithTemplate = {
        ...defaultProps,
        template: '<InvalidComponent />',
        onError
      };

      render(<TemplatePreview {...propsWithTemplate} />);
      
      // Wait for compilation to complete
      await waitFor(() => {
        expect(screen.queryByText('ðŸ”„ Compiling template...')).not.toBeInTheDocument();
      }, { timeout: 1000 });
    });

    it('should show islands status bar', async () => {
      const propsWithTemplate = {
        ...defaultProps,
        template: '<ProfilePhoto /><Bio />'
      };

      render(<TemplatePreview {...propsWithTemplate} />);
      
      await waitFor(() => {
        expect(screen.getByText('ðŸï¸ Islands Mode (Shadow DOM Isolated)')).toBeInTheDocument();
      });
    });
  });

  describe('CSS Handling', () => {
    it('should handle custom CSS in preview', async () => {
      const propsWithCSS = {
        ...defaultProps,
        template: '<ProfilePhoto />',
        customCSS: '.profile-photo { border: 2px solid red; }',
        cssMode: 'override' as const
      };

      render(<TemplatePreview {...propsWithCSS} />);
      
      // Should compile and handle CSS
      await waitFor(() => {
        expect(mockShadowRoot.querySelector).toHaveBeenCalledWith('#shadow-styles');
      });
    });

    it('should handle different CSS modes', async () => {
      const modes = ['inherit', 'override', 'disable'] as const;
      
      for (const cssMode of modes) {
        const props = {
          ...defaultProps,
          template: '<ProfilePhoto />',
          customCSS: '.test { color: red; }',
          cssMode
        };

        const { unmount } = render(<TemplatePreview {...props} />);
        
        await waitFor(() => {
          expect(mockShadowRoot.querySelector).toHaveBeenCalledWith('#shadow-styles');
        });
        
        unmount();
      }
    });
  });

  describe('Standard Layout Mode', () => {
    it('should render navigation when showNavigation is true', async () => {
      const propsWithStandardLayout = {
        ...defaultProps,
        template: '<ProfilePhoto />',
        useStandardLayout: true,
        showNavigation: true,
        siteConfig: {
          site_name: 'Test Site',
          site_tagline: 'Test Tagline',
          site_description: 'Test Description',
          footer_text: 'Test Footer'
        }
      };

      render(<TemplatePreview {...propsWithStandardLayout} />);
      
      // Should show shadow DOM initialization
      await waitFor(() => {
        expect(mockAttachShadow).toHaveBeenCalled();
      });
    });

    it('should apply different CSS for advanced vs standard templates', async () => {
      const standardProps = {
        ...defaultProps,
        template: '<ProfilePhoto />',
        useStandardLayout: true
      };

      const advancedProps = {
        ...defaultProps,
        template: '<ProfilePhoto />',
        useStandardLayout: false
      };

      // Test standard layout
      const { rerender } = render(<TemplatePreview {...standardProps} />);
      await waitFor(() => {
        expect(mockShadowRoot.querySelector).toHaveBeenCalledWith('#shadow-styles');
      });

      // Test advanced layout
      rerender(<TemplatePreview {...advancedProps} />);
      await waitFor(() => {
        expect(mockShadowRoot.querySelector).toHaveBeenCalledWith('#shadow-styles');
      });
    });
  });

  describe('Component Props and Callbacks', () => {
    it('should call onCompile callback with compiled template', async () => {
      const onCompile = jest.fn();
      const propsWithCallback = {
        ...defaultProps,
        template: '<ProfilePhoto size="large" />',
        onCompile
      };

      render(<TemplatePreview {...propsWithCallback} />);
      
      await waitFor(() => {
        expect(onCompile).toHaveBeenCalledWith(
          expect.objectContaining({
            mode: 'advanced',
            islands: expect.arrayContaining([
              expect.objectContaining({
                component: 'ProfilePhoto',
                props: expect.objectContaining({
                  size: 'large'
                })
              })
            ])
          })
        );
      }, { timeout: 1000 });
    });

    it('should call onError callback when compilation fails', async () => {
      const onError = jest.fn();
      
      // Mock compileTemplate to throw an error
      jest.doMock('../../../lib/templates/compilation/template-parser', () => ({
        compileTemplate: jest.fn(() => {
          throw new Error('Test compilation error');
        })
      }));

      const propsWithError = {
        ...defaultProps,
        template: '<ProfilePhoto />',
        onError
      };

      render(<TemplatePreview {...propsWithError} />);
      
      // Give time for compilation to attempt and fail
      await new Promise(resolve => setTimeout(resolve, 600));
    });
  });

  describe('Responsive Behavior', () => {
    it('should handle template updates efficiently', async () => {
      const { rerender } = render(<TemplatePreview {...defaultProps} />);
      
      // Update template
      rerender(
        <TemplatePreview 
          {...defaultProps} 
          template="<ProfilePhoto />" 
        />
      );
      
      await waitFor(() => {
        expect(mockShadowRoot.querySelector).toHaveBeenCalledWith('#shadow-styles');
      });
      
      // Update template again
      rerender(
        <TemplatePreview 
          {...defaultProps} 
          template="<ProfilePhoto /><Bio />" 
        />
      );
      
      // Should handle multiple updates
      await waitFor(() => {
        expect(mockShadowRoot.querySelector).toHaveBeenCalled();
      });
    });

    it('should clean up properly on unmount', () => {
      const { unmount } = render(
        <TemplatePreview 
          {...defaultProps} 
          template="<ProfilePhoto />" 
        />
      );
      
      // Should not throw on unmount
      expect(() => unmount()).not.toThrow();
    });
  });

  describe('Error Boundaries', () => {
    it('should handle rendering errors gracefully', async () => {
      // Mock console.error to avoid test noise
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      
      const propsWithPotentialError = {
        ...defaultProps,
        template: '<ProfilePhoto />',
        residentData: {
          ...createMockResidentData(),
          // Create potentially problematic data
          owner: null as any
        }
      };

      render(<TemplatePreview {...propsWithPotentialError} />);
      
      // Should render without crashing
      await waitFor(() => {
        expect(screen.queryByText('ðŸ”„ Compiling template...')).not.toBeInTheDocument();
      }, { timeout: 1000 });
      
      consoleSpy.mockRestore();
    });
  });
});