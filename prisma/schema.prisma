generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Visibility {
  public
  followers
  friends
  private
}

enum TemplateMode {
  default  // uses ProfileLayout with site CSS (default behavior)
  enhanced // custom template with site CSS applied  
  advanced // complete CSS control, no wrapper classes
}

enum UserRole {
  member
  admin
}

enum PostIntent {
  sharing      // "I am sharing..."
  asking       // "I am asking..."
  feeling      // "I am feeling..."
  announcing   // "I am announcing..."
  showing      // "I am showing..."
  teaching     // "I am teaching..."
  looking      // "I am looking for..."
  celebrating  // "I am celebrating..."
  recommending // "I am recommending..."
}

model User {
  id            String   @id @default(cuid()) // internal id
  did           String   @unique // did:key:... (portable identity)
  createdAt     DateTime @default(now())
  role          UserRole @default(member)
  // human handles (a user can have several; one primary)
  handles       Handle[]
  primaryHandle String?

  // optional email for login (encrypted at rest)
  encryptedEmail String? // AES-256-GCM encrypted email
  emailVerifiedAt DateTime? // when email was verified

  // storage pointers (future: let users point to their own stores)
  publicBaseUrl  String?
  sharedBaseUrl  String?
  privateBaseUrl String?

  profile   Profile?
  posts     Post[]
  guestbook GuestbookEntry[] @relation("EntriesToOwner") // entries left on *their* page
  installs  PluginInstall[]

  // --- auth & caps ---
  sessions     Session[]
  capabilities CapabilityGrant[]

  // --- social graph ---
  following Follow[] @relation("follows_follower") // I follow others
  followers Follow[] @relation("follows_followee") // others follow me

  comments Comment[] @relation("UserComments")
  photoComments PhotoComment[] @relation("PhotoCommentAuthor")
  betaKey  BetaKey?
  media    Media[]

  // notifications
  notificationsReceived Notification[] @relation("NotificationRecipient")
  notificationsActedOn  Notification[] @relation("NotificationActor")

  // threadrings
  curatedThreadRings     ThreadRing[]       @relation("ThreadRingCurator")
  threadRingMemberships  ThreadRingMember[] @relation("ThreadRingMemberships")
  postThreadRingAdditions PostThreadRing[]  @relation("PostThreadRingAdditions")
  threadRingInvitesSent     ThreadRingInvite[] @relation("ThreadRingInvitationsSent")
  threadRingInvitesReceived ThreadRingInvite[] @relation("ThreadRingInvitationsReceived")
  threadRingForks        ThreadRingFork[]   @relation("ThreadRingForks")
  threadRingPrompts      ThreadRingPrompt[] // Prompts created by this user
}

model Handle {
  id         String    @id @default(cuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  handle     String // e.g. "alice"
  host       String // e.g. "retro.social" or "local"
  verifiedAt DateTime?

  @@unique([handle, host])
}

model Profile {
  id                 String     @id @default(cuid())
  userId             String     @unique
  user               User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  displayName        String?
  bio                String?
  avatarUrl          String?
  avatarThumbnailUrl String? // 64x64 thumbnail
  avatarMediumUrl    String? // 200x200 medium
  avatarFullUrl      String? // 800x800 full size
  bannerUrl          String?
  customCSS          String? // store sanitized CSS or a pointer
  customTemplate     String? // raw template HTML
  customTemplateAst  String? // JSON-serialized template AST
  templateEnabled    Boolean    @default(false) // whether custom template is active
  templateMode       TemplateMode @default(default) // template rendering mode
  hideNavigation     Boolean    @default(false) // hide navbar and footer on custom template
  blogroll           Json? // [{label,url,blurb}]
  featuredFriends    Json? // [{id,handle,displayName,avatarUrl}]
  visibility         Visibility @default(public)
  updatedAt          DateTime   @updatedAt
}

model Post {
  id           String      @id @default(cuid())
  authorId     String
  author       User        @relation(fields: [authorId], references: [id], onDelete: Cascade)
  title        String      @default("Untitled Post")
  intent       PostIntent? // Optional intent stamp
  createdAt    DateTime    @default(now())
  updatedAt    DateTime?
  bodyHtml     String?
  bodyText     String?
  bodyMarkdown String?
  media        Json? // [{url,mime,width,height}]
  tags         String[]
  visibility   Visibility  @default(public)
  comments     Comment[]   @relation("PostComments")
  threadRings  PostThreadRing[] @relation("PostThreadRings")
  promptResponses PostThreadRingPrompt[] // Prompt responses
  // future: signature, cid
}

// schema.prisma
enum CommentStatus {
  visible
  hidden   // removed by moderator/author
}

model Comment {
  id        String         @id @default(cuid())
  content   String
  createdAt DateTime       @default(now())

  // existing FKs
  postId    String
  authorId  String

  // relations (as you already have)
  post      Post           @relation("PostComments", fields: [postId], references: [id], onDelete: Cascade)
  author    User           @relation("UserComments", fields: [authorId], references: [id], onDelete: Cascade)

  // NEW: nested comments support
  parentId  String?
  parent    Comment?       @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[]      @relation("CommentReplies")
  
  status    CommentStatus  @default(visible)
}

model GuestbookEntry {
  id           String   @id @default(cuid())
  profileOwner String // whose page the entry lives on
  owner        User     @relation("EntriesToOwner", fields: [profileOwner], references: [id], onDelete: Cascade)
  authorId     String? // DID owner or null for anonymous (we'll map DID â†’ user later)
  message      String
  createdAt    DateTime @default(now())
  status       String   @default("visible") // visible|hidden|removed
  signature    String? // optional
}

model PluginInstall {
  id        String   @id @default(cuid())
  ownerId   String
  owner     User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  pluginId  String // "com.example.hello"
  mode      String // "trusted" | "iframe"
  settings  Json? // plugin-specific config
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  issuedAt  DateTime @default(now())
  expiresAt DateTime
  // store a random secret to bind cookie to server state
  secret    String   @unique
}

enum EmailTokenType {
  login        // For magic link login
  verification // For email verification
}

model EmailLoginToken {
  id        String   @id @default(cuid())
  token     String   @unique // secure random token for email login
  encryptedEmail String // encrypted email this token is for
  type      EmailTokenType @default(login) // token type
  userId    String?  // for verification tokens, the user setting the email
  expiresAt DateTime // short expiration (15 minutes)
  usedAt    DateTime? // when token was used (null = unused)
  createdAt DateTime @default(now())
  
  @@index([token])
  @@index([encryptedEmail, expiresAt])
  @@index([userId, type])
}

model CapabilityGrant {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  audience  String // "origin/service" that this token is for (e.g. "retro.local")
  actions   String[] // ["read:shared","write:post"]
  resource  String // e.g. "did:.../posts/*"
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model Follow {
  followerId String
  followeeId String
  follower   User     @relation("follows_follower", fields: [followerId], references: [id], onDelete: Cascade)
  followee   User     @relation("follows_followee", fields: [followeeId], references: [id], onDelete: Cascade)
  status     String   @default("accepted") // requested | accepted | blocked
  createdAt  DateTime @default(now())

  @@id([followerId, followeeId])
}

model BetaKey {
  id        String    @id @default(cuid())
  key       String    @unique // the actual beta key string
  usedBy    String?   @unique // user ID who used this key
  user      User?     @relation(fields: [usedBy], references: [id])
  createdAt DateTime  @default(now())
  usedAt    DateTime?
}

enum NotificationType {
  comment       // someone commented on your post
  reply         // someone replied to your comment
  photo_comment // someone commented on your photo
  photo_reply   // someone replied to your photo comment
  follow        // someone followed you
  friend        // someone became mutual friend
  guestbook     // someone signed your guestbook
  threadring_invite // invited to join a threadring
  threadring_join   // someone joined your threadring
  threadring_post   // new post in a threadring you're in
  threadring_fork   // someone forked your threadring
}

enum NotificationStatus {
  unread
  read
  dismissed
}

model Notification {
  id          String             @id @default(cuid())
  recipientId String             // who receives this notification
  recipient   User               @relation("NotificationRecipient", fields: [recipientId], references: [id], onDelete: Cascade)
  
  actorId     String             // who performed the action
  actor       User               @relation("NotificationActor", fields: [actorId], references: [id], onDelete: Cascade)
  
  type        NotificationType
  status      NotificationStatus @default(unread)
  
  // contextual data (JSON for flexibility)
  data        Json?              // {postId, commentId, etc.}
  
  createdAt   DateTime           @default(now())
  readAt      DateTime?
  
  @@index([recipientId, status, createdAt])
  @@index([recipientId, actorId, type])
}

model SiteConfig {
  id    String @id @default(cuid())
  key   String @unique
  value String
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([key])
}

model CustomPage {
  id          String   @id @default(cuid())
  slug        String   @unique // URL slug like "about", "rules", etc.
  title       String
  content     String   // HTML content
  published   Boolean  @default(false)
  showInNav   Boolean  @default(false) // Show in navigation menu
  navOrder    Int      @default(0)     // Order in navigation (lower = earlier)
  hideNavbar  Boolean  @default(false) // Hide navigation bar on this page
  isHomepage  Boolean  @default(false) // Use this page as the site homepage
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([published, showInNav, navOrder])
  @@index([isHomepage])
}

model Media {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Personal story/caption
  caption      String?  // The story behind the image
  title        String?  // Optional title
  
  // Image URLs (multiple sizes)
  thumbnailUrl String   // Small thumbnail
  mediumUrl    String   // Medium size for gallery
  fullUrl      String   // Full size for viewing
  originalName String?  // Original filename
  
  // Metadata
  fileSize     Int?     // File size in bytes
  mimeType     String?  // image/jpeg, etc.
  width        Int?     // Image width
  height       Int?     // Image height
  
  // Display settings
  featured     Boolean  @default(false) // Show in media tab (max 6)
  featuredOrder Int?    // Order in featured media (1-6)
  visibility   Visibility @default(public)
  
  // Comments
  comments     PhotoComment[]
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([userId, featured, featuredOrder])
  @@index([userId, createdAt])
  @@index([userId, visibility])
}

model PhotoComment {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now())
  
  // Relations
  mediaId   String
  media     Media    @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  authorId  String
  author    User     @relation("PhotoCommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  
  // Nested comments support
  parentId  String?
  parent    PhotoComment? @relation("PhotoCommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   PhotoComment[] @relation("PhotoCommentReplies")
  
  status    CommentStatus @default(visible)
  
  @@index([mediaId, createdAt])
  @@index([authorId, createdAt])
  @@index([parentId])
}

enum ThreadRingJoinType {
  open     // Anyone can join
  invite   // Invitation only
  closed   // No new members
}

enum ThreadRingVisibility {
  public   // Visible in directory, searchable
  unlisted // Direct link only
  private  // Members only
}

enum ThreadRingRole {
  member
  moderator
  curator
}

model ThreadRing {
  id          String   @id @default(cuid())
  uri         String   @unique // Canonical URI for federation
  curatorId   String   // User who created/manages the ring
  curator     User     @relation("ThreadRingCurator", fields: [curatorId], references: [id], onDelete: Cascade)
  
  name        String   // Display name of the ring
  slug        String   @unique // URL-friendly identifier
  description String?  // Optional description/rules
  
  // Ring settings
  joinType    ThreadRingJoinType @default(open)
  visibility  ThreadRingVisibility @default(public)
  
  // Hierarchical fields for The Spool architecture
  parentId          String?    // Direct parent ThreadRing (null only for The Spool)
  parent            ThreadRing? @relation("ThreadRingHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children          ThreadRing[] @relation("ThreadRingHierarchy")
  
  // Denormalized counters for performance
  memberCount           Int    @default(1) // Start with 1 (the curator)
  postCount             Int    @default(0)
  directChildrenCount   Int    @default(0) // Immediate children only
  totalDescendantsCount Int    @default(0) // ALL descendants (recursive)
  
  // Cached lineage data for efficient queries
  lineageDepth    Int    @default(0)    // How deep in the tree (Spool = 0)
  lineagePath     String @default("")   // Comma-separated ancestor IDs for quick queries
  
  // Special system flags
  isSystemRing    Boolean @default(false) // True for The Spool
  
  // Ring content
  currentPrompt    String?  // Current prompt/challenge for members
  curatorNote      String?  // Pinned curator's note
  
  // Ring members
  members     ThreadRingMember[]
  
  // Posts associated with this ring
  posts       PostThreadRing[]
  
  // Invitations
  invites     ThreadRingInvite[]
  
  // Fork relationships
  parentForks ThreadRingFork[] @relation("ThreadRingParent")
  childFork   ThreadRingFork?  @relation("ThreadRingChild")
  
  // Badge
  badge       ThreadRingBadge?
  
  // Prompts/Challenges
  prompts     ThreadRingPrompt[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([curatorId])
  @@index([slug])
  @@index([uri])
  @@index([visibility, joinType])
  @@index([memberCount, postCount]) // For trending calculation
  @@index([parentId]) // For hierarchical queries
  @@index([lineageDepth]) // For depth-based queries
  @@index([isSystemRing]) // For system ring queries
}

model ThreadRingMember {
  id           String     @id @default(cuid())
  threadRingId String
  threadRing   ThreadRing @relation(fields: [threadRingId], references: [id], onDelete: Cascade)
  userId       String
  user         User       @relation("ThreadRingMemberships", fields: [userId], references: [id], onDelete: Cascade)
  
  role         ThreadRingRole @default(member)
  joinedAt     DateTime       @default(now())
  
  @@unique([threadRingId, userId])
  @@index([userId])
  @@index([threadRingId, role])
}

model PostThreadRing {
  id           String     @id @default(cuid())
  postId       String
  post         Post       @relation("PostThreadRings", fields: [postId], references: [id], onDelete: Cascade)
  threadRingId String
  threadRing   ThreadRing @relation(fields: [threadRingId], references: [id], onDelete: Cascade)
  
  addedAt      DateTime   @default(now())
  addedBy      String     // User who associated the post with the ring
  addedByUser  User       @relation("PostThreadRingAdditions", fields: [addedBy], references: [id], onDelete: Cascade)
  
  // Moderation
  isPinned     Boolean    @default(false) // Curator can pin/feature posts
  pinnedAt     DateTime?
  pinnedBy     String?
  
  @@unique([postId, threadRingId])
  @@index([threadRingId, addedAt])
  @@index([threadRingId, isPinned, pinnedAt]) // For pinned posts query
  @@index([postId])
}

model ThreadRingInvite {
  id           String     @id @default(cuid())
  threadRingId String
  threadRing   ThreadRing @relation(fields: [threadRingId], references: [id], onDelete: Cascade)
  inviterId    String
  inviter      User       @relation("ThreadRingInvitationsSent", fields: [inviterId], references: [id], onDelete: Cascade)
  inviteeId    String
  invitee      User       @relation("ThreadRingInvitationsReceived", fields: [inviteeId], references: [id], onDelete: Cascade)
  
  status       ThreadRingInviteStatus @default(pending)
  createdAt    DateTime               @default(now())
  respondedAt  DateTime?
  
  @@unique([threadRingId, inviteeId])
  @@index([inviteeId, status])
  @@index([threadRingId])
}

enum ThreadRingInviteStatus {
  pending
  accepted
  declined
  revoked
}

// =====================================================
// THREADRINGS FEATURE PLANNING NOTES
// =====================================================
// 
// ThreadRings are communities reminiscent of old webrings but with a modern twist.
// Each ThreadRing has:
// - A curator (creator/owner) who manages the ring
// - Members who can post to the ring
// - Posts that members can associate with one or more rings
// - A dedicated page showing ring posts, member list, and ring info
// - Join settings: open join, invite only, or closed
//
// DATABASE SCHEMA ADDITIONS NEEDED:
//
// model ThreadRing {
//   id          String   @id @default(cuid())
//   uri         String   @unique // Canonical URI for federation (e.g. "threadstead.local/rings/webdev")
//   curatorId   String   // User who created/manages the ring
//   curator     User     @relation("ThreadRingCurator", fields: [curatorId], references: [id], onDelete: Cascade)
//   
//   name        String   // Display name of the ring
//   slug        String   @unique // URL-friendly identifier
//   description String?  // Optional description/rules
//   
//   // Ring settings
//   joinType    ThreadRingJoinType @default(open) // open, invite, closed
//   visibility  ThreadRingVisibility @default(public) // public, unlisted, private
//   
//   // Denormalized counters for performance
//   memberCount Int      @default(0)
//   postCount   Int      @default(0)
//   
//   // Ring content
//   currentPrompt    String?  // Current prompt/challenge for members
//   curatorNote      String?  // Pinned curator's note
//   themeCss         String?  // Custom CSS theme (future)
//   
//   // Ring members
//   members     ThreadRingMember[]
//   
//   // Posts associated with this ring
//   posts       PostThreadRing[]
//   
//   // Invitations
//   invites     ThreadRingInvite[]
//   
//   // Moderation
//   blockedActors String[]  // URIs of blocked actors/instances
//   auditLogs     ThreadRingAuditLog[]
//   
//   createdAt   DateTime @default(now())
//   updatedAt   DateTime @updatedAt
//   
//   @@index([curatorId])
//   @@index([slug])
//   @@index([uri])
//   @@index([visibility, joinType])
//   @@index([memberCount, postCount]) // For trending calculation
// }
//
// enum ThreadRingJoinType {
//   open     // Anyone can join
//   invite   // Invitation only
//   closed   // No new members
// }
//
// enum ThreadRingVisibility {
//   public   // Visible in directory, searchable
//   unlisted // Direct link only
//   private  // Members only
// }
//
// model ThreadRingMember {
//   id           String     @id @default(cuid())
//   threadRingId String
//   threadRing   ThreadRing @relation(fields: [threadRingId], references: [id], onDelete: Cascade)
//   userId       String
//   user         User       @relation("ThreadRingMemberships", fields: [userId], references: [id], onDelete: Cascade)
//   
//   role         ThreadRingRole @default(member)
//   joinedAt     DateTime       @default(now())
//   
//   @@unique([threadRingId, userId])
//   @@index([userId])
//   @@index([threadRingId, role])
// }
//
// enum ThreadRingRole {
//   member
//   moderator
//   curator
// }
//
// model PostThreadRing {
//   id           String     @id @default(cuid())
//   postId       String
//   post         Post       @relation("PostThreadRings", fields: [postId], references: [id], onDelete: Cascade)
//   threadRingId String
//   threadRing   ThreadRing @relation(fields: [threadRingId], references: [id], onDelete: Cascade)
//   
//   addedAt      DateTime   @default(now())
//   addedBy      String     // User who associated the post with the ring
//   addedByUser  User       @relation("PostThreadRingAdditions", fields: [addedBy], references: [id], onDelete: Cascade)
//   
//   // Moderation
//   isPinned     Boolean    @default(false) // Curator can pin/feature posts
//   pinnedAt     DateTime?
//   pinnedBy     String?
//   
//   @@unique([postId, threadRingId])
//   @@index([threadRingId, addedAt])
//   @@index([threadRingId, isPinned, pinnedAt]) // For pinned posts query
//   @@index([postId])
// }
//
// model ThreadRingInvite {
//   id           String     @id @default(cuid())
//   threadRingId String
//   threadRing   ThreadRing @relation(fields: [threadRingId], references: [id], onDelete: Cascade)
//   inviterId    String
//   inviter      User       @relation("ThreadRingInvitationsSent", fields: [inviterId], references: [id], onDelete: Cascade)
//   inviteeId    String
//   invitee      User       @relation("ThreadRingInvitationsReceived", fields: [inviteeId], references: [id], onDelete: Cascade)
//   
//   status       ThreadRingInviteStatus @default(pending)
//   createdAt    DateTime               @default(now())
//   respondedAt  DateTime?
//   
//   @@unique([threadRingId, inviteeId])
//   @@index([inviteeId, status])
//   @@index([threadRingId])
// }
//
// enum ThreadRingInviteStatus {
//   pending
//   accepted
//   declined
//   revoked
// }
//
// UPDATES TO EXISTING MODELS:
//
// Add to User model:
//   curatedThreadRings     ThreadRing[]       @relation("ThreadRingCurator")
//   threadRingMemberships  ThreadRingMember[] @relation("ThreadRingMemberships")
//   postThreadRingAdditions PostThreadRing[]  @relation("PostThreadRingAdditions")
//   threadRingInvitesSent     ThreadRingInvite[] @relation("ThreadRingInvitationsSent")
//   threadRingInvitesReceived ThreadRingInvite[] @relation("ThreadRingInvitationsReceived")
//
// Add to Post model:
//   threadRings PostThreadRing[] @relation("PostThreadRings")
//
model ThreadRingFork {
  id               String     @id @default(cuid())
  parentId         String     // The ring that was forked (parent)
  parent           ThreadRing @relation("ThreadRingParent", fields: [parentId], references: [id], onDelete: Cascade)
  childId          String     @unique // The new ring created from the fork (child)
  child            ThreadRing @relation("ThreadRingChild", fields: [childId], references: [id], onDelete: Cascade)
  createdBy        String     // User who performed the fork
  createdByUser    User       @relation("ThreadRingForks", fields: [createdBy], references: [id], onDelete: Cascade)
  
  forkReason       String?    // Optional reason/description for the fork
  createdAt        DateTime   @default(now())
  
  @@index([parentId])
  @@index([createdBy])
}

model ThreadRingBadge {
  id           String     @id @default(cuid())
  threadRingId String     @unique // One badge per ThreadRing
  threadRing   ThreadRing @relation(fields: [threadRingId], references: [id], onDelete: Cascade)
  
  // Badge content
  title        String     // Text displayed on badge (ThreadRing name)
  subtitle     String?    // Optional subtitle/tagline
  
  // Badge image options
  imageUrl     String?    // Custom uploaded image URL
  templateId   String?    // Reference to badge template
  backgroundColor String  @default("#4A90E2") // Hex color for background
  textColor       String  @default("#FFFFFF") // Hex color for text
  
  // Badge metadata
  isGenerated  Boolean    @default(true)  // Auto-generated vs custom
  isActive     Boolean    @default(true)  // Whether badge is currently displayed
  
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  
  @@index([threadRingId])
  @@index([isActive])
}

enum BadgeTemplate {
  classic_blue
  retro_green  
  sunset_orange
  midnight_purple
  matrix_green
  neon_pink
  vintage_brown
  cyber_teal
}

//
// model ThreadRingAuditLog {
//   id           String               @id @default(cuid())
//   threadRingId String
//   threadRing   ThreadRing           @relation(fields: [threadRingId], references: [id], onDelete: Cascade)
//   actorId      String               // User who performed the action
//   actor        User                 @relation("ThreadRingAuditActor", fields: [actorId], references: [id], onDelete: Cascade)
//   
//   action       ThreadRingAuditAction
//   targetType   String?              // "user", "post", "ring"
//   targetId     String?              // ID of the target
//   targetUri    String?              // URI for federation
//   oldValue     Json?                // Previous state
//   newValue     Json?                // New state
//   reason       String?              // Reason for the action
//   
//   createdAt    DateTime             @default(now())
//   
//   @@index([threadRingId, createdAt])
//   @@index([actorId, createdAt])
// }
//
// enum ThreadRingAuditAction {
//   member_add
//   member_remove
//   member_role_change
//   post_remove
//   post_pin
//   post_unpin
//   ring_update
//   user_block
//   user_unblock
// }
//
// UPDATES TO EXISTING MODELS (ADDITIONAL):
//
// Add to ThreadRing model:
//   originalForks    ThreadRingFork[] @relation("ThreadRingOriginal")  // Rings forked from this one
//   forkedFrom       ThreadRingFork?  @relation("ThreadRingForked")    // If this ring is a fork
//
// Add to User model:
//   threadRingForks     ThreadRingFork[]     @relation("ThreadRingForks")
//   threadRingAudits    ThreadRingAuditLog[] @relation("ThreadRingAuditActor")
//
// Add to Post model:
//   uri          String?  @unique // Canonical URI for federation
//
// FEDERATION-READY MODELS (Optional now, saves migration pain later):
//
// model Actor {
//   id        String    @id @default(cuid())
//   uri       String    @unique // Actor URI (local or remote)
//   type      ActorType // Person, Group, etc.
//   inbox     String?   // ActivityPub inbox URL
//   outbox    String?   // ActivityPub outbox URL
//   publicKey String?   // PEM-encoded public key
//   
//   // Local actor details (null for remote actors)
//   userId    String?   @unique
//   user      User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
//   
//   createdAt DateTime  @default(now())
//   updatedAt DateTime  @updatedAt
//   
//   @@index([uri])
//   @@index([type])
// }
//
// enum ActorType {
//   Person
//   Group
//   Service
// }
//
// model OutboxEvent {
//   id        String   @id @default(cuid())
//   actorUri  String   // Actor who generated this event
//   type      String   // ActivityPub activity type
//   object    Json     // Activity object
//   published DateTime @default(now())
//   
//   // Delivery tracking
//   deliveries Delivery[]
//   
//   @@index([actorUri, published])
// }
//
// model InboxMessage {
//   id        String   @id @default(cuid())
//   targetUri String   // Actor who should receive this
//   type      String   // ActivityPub activity type
//   object    Json     // Activity object
//   signature String?  // HTTP signature for verification
//   processed Boolean  @default(false)
//   
//   receivedAt DateTime @default(now())
//   processedAt DateTime?
//   
//   @@index([targetUri, processed])
//   @@index([receivedAt])
// }
//
// model Delivery {
//   id           String        @id @default(cuid())
//   eventId      String
//   event        OutboxEvent   @relation(fields: [eventId], references: [id], onDelete: Cascade)
//   targetInbox  String        // Remote inbox URL
//   attempts     Int           @default(0)
//   status       DeliveryStatus @default(pending)
//   lastAttempt  DateTime?
//   nextAttempt  DateTime?
//   error        String?
//   
//   @@index([status, nextAttempt])
//   @@index([eventId])
// }
//
// enum DeliveryStatus {
//   pending
//   delivered
//   failed
//   permanent_failure
// }
//
model ThreadRingPrompt {
  id           String      @id @default(cuid())
  threadRingId String
  threadRing   ThreadRing  @relation(fields: [threadRingId], references: [id], onDelete: Cascade)
  
  // Prompt details
  title        String      // Short title for the prompt
  description  String      // Full prompt description/challenge
  
  // Timing
  startsAt     DateTime    @default(now()) // When the prompt becomes active
  endsAt       DateTime?   // Optional deadline for responses
  
  // Status
  isActive     Boolean     @default(true) // Whether this is the current active prompt
  isPinned     Boolean     @default(false) // Keep visible even after new prompts
  
  // Response tracking
  responseCount Int        @default(0) // Denormalized count of responses
  
  // Creator tracking
  createdById  String      // User who created the prompt (usually curator)
  createdBy    User        @relation(fields: [createdById], references: [id], onDelete: Cascade)
  
  // Responses (posts associated with this prompt)
  responses    PostThreadRingPrompt[]
  
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  
  @@index([threadRingId, isActive])
  @@index([threadRingId, startsAt])
  @@index([threadRingId, isPinned])
}

model PostThreadRingPrompt {
  id         String           @id @default(cuid())
  postId     String
  post       Post             @relation(fields: [postId], references: [id], onDelete: Cascade)
  promptId   String
  prompt     ThreadRingPrompt @relation(fields: [promptId], references: [id], onDelete: Cascade)
  
  createdAt  DateTime         @default(now())
  
  @@unique([postId, promptId])
  @@index([promptId, createdAt]) // For fetching prompt responses
  @@index([postId])
}

// NOTIFICATION UPDATES:
// Add to NotificationType enum:
//   threadring_invite    // invited to join a threadring
//   threadring_join      // someone joined your threadring
//   threadring_post      // new post in a threadring you're in
//   threadring_fork      // someone forked your threadring (soft notification)
//
// =====================================================
