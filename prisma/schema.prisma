generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                        String                        @id @default(cuid())
  did                       String                        @unique
  createdAt                 DateTime                      @default(now())
  primaryHandle             String?
  publicBaseUrl             String?
  sharedBaseUrl             String?
  privateBaseUrl            String?
  role                      UserRole                      @default(member)
  emailVerifiedAt           DateTime?
  encryptedEmail            String?
  passwordHash              String? // For password-based auth
  encryptedSeedPhrase       String? // Encrypted with user's password
  authMethod                AuthMethod                    @default(SEED_PHRASE)
  betaKey                   BetaKey?
  capabilities              CapabilityGrant[]
  comments                  Comment[]                     @relation("UserComments")
  followers                 Follow[]                      @relation("follows_followee")
  following                 Follow[]                      @relation("follows_follower")
  guestbook                 GuestbookEntry[]              @relation("EntriesToOwner")
  handles                   Handle[]
  media                     Media[]
  notificationsActedOn      Notification[]                @relation("NotificationActor")
  notificationsReceived     Notification[]                @relation("NotificationRecipient")
  photoComments             PhotoComment[]                @relation("PhotoCommentAuthor")
  installs                  PluginInstall[]
  posts                     Post[]
  postViews                 PostView[]                    @relation("PostViews")
  postThreadRingAdditions   PostThreadRing[]              @relation("PostThreadRingAdditions")
  profile                   Profile?
  homeConfig                UserHomeConfig?
  ringHubOwnerships         RingHubOwnership[]            @relation("RingHubOwnerships")
  sessions                  Session[]
  curatedThreadRings        ThreadRing[]                  @relation("ThreadRingCurator")
  threadRingBlocksReceived  ThreadRingBlock[]             @relation("ThreadRingBlockedUsers")
  threadRingBlocksCreated   ThreadRingBlock[]             @relation("ThreadRingBlockCreators")
  threadRingForks           ThreadRingFork[]              @relation("ThreadRingForks")
  threadRingInvitesReceived ThreadRingInvite[]            @relation("ThreadRingInvitationsReceived")
  threadRingInvitesSent     ThreadRingInvite[]            @relation("ThreadRingInvitationsSent")
  threadRingMemberships     ThreadRingMember[]            @relation("ThreadRingMemberships")
  reportsCreated            UserReport[]                  @relation("UserReportsCreated")
  reportsReceived           UserReport[]                  @relation("UserReportsReceived")
  reportsReviewed           UserReport[]                  @relation("UserReportsReviewed")
  blocksCreated             UserBlock[]                   @relation("UserBlocksCreated")
  blocksReceived            UserBlock[]                   @relation("UserBlocksReceived")
  pixelHomeVisitors         PixelHomeVisitor[]            @relation("PixelHomeOwner")
  pixelHomeVisits           PixelHomeVisitor[]            @relation("PixelHomeVisitor")
  betaInviteCodesGenerated  BetaInviteCode[]              @relation("BetaInviteCodesGenerated")
  betaInviteCodesUsed       BetaInviteCode[]              @relation("BetaInviteCodesUsed")
  betaInviteShares          BetaInviteShare[]             @relation("BetaInviteShares")
  emojisCreated             Emoji[]                       @relation("EmojiCreator")
  decorationItemsCreated    DecorationItem[]              @relation("DecorationItemsCreated")
  decorationClaims          UserDecorationClaim[]         @relation("UserDecorationClaims")
  siteNewsCreated           SiteNews[]                    @relation("SiteNewsAuthor")
  betaLandingPagesCreated   BetaLandingPage[]             @relation("BetaLandingPagesCreated")
  betaLandingPagesEnded     BetaLandingPage[]             @relation("BetaLandingPagesEnded")
  betaLandingSignups        BetaLandingSignup[]           @relation("BetaLandingSignups")
  ipBlocksCreated           IpSignupTracking[]            @relation("IpBlocksCreated")
  signupAttempts            SignupAttempt[]               @relation("SignupAttempts")
  consents                  UserConsent[]                 @relation("UserConsents")
  consentLogs               ConsentLog[]                  @relation("ConsentLogs")
  indexedSiteSubmissions    IndexedSite[]                 @relation("IndexedSiteSubmissions")
  indexedSiteVerifications  IndexedSite[]                 @relation("IndexedSiteVerifications")
  siteVotes                 SiteVote[]                    @relation("SiteVotes")
  siteTagSuggestions        SiteTag[]                     @relation("SiteTagSuggestions")
  discoveryPaths            DiscoveryPath[]               @relation("DiscoveryPaths")
  siteReviews               SiteReview[]                  @relation("SiteReviews")
  userCollections           UserCollection[]              @relation("UserCollections")
  userBookmarks             UserBookmark[]                @relation("UserBookmarks")
  bookmarkValidations       BookmarkCommunitySubmission[] @relation("BookmarkValidations")
}

model Handle {
  id         String    @id @default(cuid())
  userId     String
  handle     String
  host       String
  verifiedAt DateTime?
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([handle, host])
}

model Profile {
  id                 String       @id @default(cuid())
  userId             String       @unique
  displayName        String?
  bio                String?
  avatarUrl          String?
  bannerUrl          String?
  customCSS          String?
  blogroll           Json?
  visibility         Visibility   @default(public)
  updatedAt          DateTime     @updatedAt
  featuredFriends    Json?
  avatarFullUrl      String?
  avatarMediumUrl    String?
  avatarThumbnailUrl String?
  customTemplate     String?
  customTemplateAst  String?
  hideNavigation     Boolean      @default(false)
  templateEnabled    Boolean      @default(false)
  templateMode       TemplateMode @default(default)
  badgePreferences   Json?
  includeSiteCSS     Boolean      @default(true)
  profileMidiId      String?
  midiAutoplay       Boolean      @default(false)
  midiLoop           Boolean      @default(false)
  compiledTemplate   Json?
  templateIslands    Json?
  templateCompiledAt DateTime?
  user               User         @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserHomeConfig {
  userId              String   @id
  houseTemplate       String   @default("cottage_v1")
  palette             String   @default("thread_sage")
  bookSkin            String?  @default("linen_v1")
  seasonalOptIn       Boolean  @default(false)
  preferPixelHome     Boolean  @default(false)
  atmosphereSky       String   @default("sunny") // sunny, cloudy, sunset, night
  atmosphereWeather   String   @default("clear") // clear, light_rain, light_snow
  atmosphereTimeOfDay String   @default("midday") // morning, midday, evening, night
  // House color customizations
  wallColor           String? // Override base color
  roofColor           String? // Override primary color
  trimColor           String? // Override secondary color
  windowColor         String? // Override accent color
  detailColor         String? // Override detail color
  // House style customizations
  windowStyle         String?  @default("default") // default, round, arched, bay
  doorStyle           String?  @default("default") // default, arched, double, cottage
  roofTrim            String?  @default("default") // default, ornate, scalloped, gabled
  // House text customizations
  houseTitle          String? // Custom title text shown above house description (max 50 characters)
  houseDescription    String? // Custom description text shown below house (max 200 characters)
  houseBoardText      String? // Custom text shown on house board/sign (max 30 characters)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  user        User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  decorations UserHomeDecoration[]
}

model UserHomeDecoration {
  id             String   @id @default(cuid())
  userId         String
  decorationType String // plant, path, feature, seasonal
  decorationId   String // roses_red, stone_path, bird_bath, etc.
  zone           String // front_yard, house_facade, background
  positionX      Int // X coordinate on canvas
  positionY      Int // Y coordinate on canvas
  layer          Int      @default(1) // Z-layer for rendering order
  variant        String? // color variant, size, etc.
  size           String?  @default("medium") // small, medium, large
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  homeConfig UserHomeConfig @relation(fields: [userId], references: [userId], onDelete: Cascade)

  @@index([userId])
  @@index([userId, zone])
}

model PixelHomeVisitor {
  id          String   @id @default(cuid())
  homeOwnerId String
  visitorId   String
  visitedAt   DateTime @default(now())

  homeOwner User @relation("PixelHomeOwner", fields: [homeOwnerId], references: [id], onDelete: Cascade)
  visitor   User @relation("PixelHomeVisitor", fields: [visitorId], references: [id], onDelete: Cascade)

  @@unique([homeOwnerId, visitorId])
  @@index([homeOwnerId, visitedAt])
  @@index([visitorId, visitedAt])
}

model Post {
  id                String           @id @default(cuid())
  authorId          String
  createdAt         DateTime         @default(now())
  updatedAt         DateTime?
  bodyHtml          String?
  bodyText          String?
  media             Json?
  tags              String[]
  visibility        Visibility       @default(public)
  bodyMarkdown      String?
  title             String           @default("Untitled Post")
  intent            PostIntent?
  excerpt           String?
  platform          String?          @default("blog")
  publishedAt       DateTime?
  textPreview       String?
  contentWarning    String? // Custom spoiler warning text
  isSpoiler         Boolean          @default(false) // Quick flag for filtering
  threadRingPostIds Json? // Store ThreadRing database UUIDs mapped by ring slug
  comments          Comment[]        @relation("PostComments")
  author            User             @relation(fields: [authorId], references: [id], onDelete: Cascade)
  threadRings       PostThreadRing[] @relation("PostThreadRings")
  metrics           PostMetrics?     @relation("PostMetrics")
  views             PostView[]       @relation("PostViews")

  // Search performance indexes
  @@index([visibility, createdAt])
}

model PostMetrics {
  id              String    @id @default(cuid())
  postId          String    @unique
  viewCount       Int       @default(0)
  uniqueViewCount Int       @default(0)
  commentCount    Int       @default(0)
  lastViewedAt    DateTime  @default(now())
  lastCommentAt   DateTime?
  trendingScore   Float     @default(0)
  scoreUpdatedAt  DateTime  @default(now())

  // Velocity tracking (last 6 hours)
  recentViews    Int      @default(0)
  recentComments Int      @default(0)
  velocityWindow DateTime @default(now())

  post Post @relation("PostMetrics", fields: [postId], references: [id], onDelete: Cascade)

  @@index([trendingScore, scoreUpdatedAt])
  @@index([postId])
}

model PostView {
  id        String   @id @default(cuid())
  postId    String
  userId    String?
  ipHash    String?
  viewType  String   @default("feed")
  createdAt DateTime @default(now())

  post Post  @relation("PostViews", fields: [postId], references: [id], onDelete: Cascade)
  user User? @relation("PostViews", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId, createdAt])
  @@unique([postId, ipHash, createdAt])
  @@index([postId, createdAt])
  @@index([createdAt])
}

model Comment {
  id        String        @id @default(cuid())
  content   String
  createdAt DateTime      @default(now())
  postId    String
  authorId  String
  status    CommentStatus @default(visible)
  parentId  String?
  author    User          @relation("UserComments", fields: [authorId], references: [id], onDelete: Cascade)
  parent    Comment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[]     @relation("CommentReplies")
  post      Post          @relation("PostComments", fields: [postId], references: [id], onDelete: Cascade)
}

model GuestbookEntry {
  id           String   @id @default(cuid())
  profileOwner String
  authorId     String?
  message      String
  createdAt    DateTime @default(now())
  status       String   @default("visible")
  signature    String?
  owner        User     @relation("EntriesToOwner", fields: [profileOwner], references: [id], onDelete: Cascade)
}

model PluginInstall {
  id        String   @id @default(cuid())
  ownerId   String
  pluginId  String
  mode      String
  settings  Json?
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  owner     User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  issuedAt  DateTime @default(now())
  expiresAt DateTime
  secret    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model EmailLoginToken {
  id             String         @id @default(cuid())
  token          String         @unique
  encryptedEmail String
  expiresAt      DateTime
  usedAt         DateTime?
  createdAt      DateTime       @default(now())
  type           EmailTokenType @default(login)
  userId         String?

  @@index([token])
  @@index([encryptedEmail, expiresAt])
  @@index([userId, type])
}

model CapabilityGrant {
  id        String   @id @default(cuid())
  userId    String
  audience  String
  actions   String[]
  resource  String
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Follow {
  followerId String
  followeeId String
  status     String   @default("accepted")
  createdAt  DateTime @default(now())
  followee   User     @relation("follows_followee", fields: [followeeId], references: [id], onDelete: Cascade)
  follower   User     @relation("follows_follower", fields: [followerId], references: [id], onDelete: Cascade)

  @@id([followerId, followeeId])
}

model BetaKey {
  id        String    @id @default(cuid())
  key       String    @unique
  usedBy    String?   @unique
  createdAt DateTime  @default(now())
  usedAt    DateTime?
  user      User?     @relation(fields: [usedBy], references: [id])
}

model BetaInviteCode {
  id          String            @id @default(cuid())
  code        String            @unique
  generatedBy String
  usedBy      String?
  createdAt   DateTime          @default(now())
  usedAt      DateTime?
  generator   User              @relation("BetaInviteCodesGenerated", fields: [generatedBy], references: [id], onDelete: Cascade)
  user        User?             @relation("BetaInviteCodesUsed", fields: [usedBy], references: [id], onDelete: SetNull)
  shares      BetaInviteShare[]

  @@index([generatedBy])
  @@index([code])
}

model Notification {
  id          String             @id @default(cuid())
  recipientId String
  actorId     String
  type        NotificationType
  status      NotificationStatus @default(unread)
  data        Json?
  createdAt   DateTime           @default(now())
  readAt      DateTime?
  actor       User               @relation("NotificationActor", fields: [actorId], references: [id], onDelete: Cascade)
  recipient   User               @relation("NotificationRecipient", fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([recipientId, status, createdAt])
  @@index([recipientId, actorId, type])
}

model SiteConfig {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([key])
}

model CustomPage {
  id            String   @id @default(cuid())
  slug          String   @unique
  title         String
  content       String
  published     Boolean  @default(false)
  showInNav     Boolean  @default(false)
  navOrder      Int      @default(0)
  navDropdown   String? // Which dropdown menu (e.g., "discovery", "help", null for top-level)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  hideNavbar    Boolean  @default(false)
  isHomepage    Boolean  @default(false)
  isLandingPage Boolean  @default(false)

  @@index([published, showInNav, navOrder])
  @@index([isHomepage])
  @@index([isLandingPage])
  @@index([navDropdown])
}

model CuratedSite {
  id          String    @id @default(cuid())
  url         String    @unique
  title       String
  description String
  tags        String[] // Array of tags like ['indie', 'blog', 'creative']
  active      Boolean   @default(true)
  weight      Int       @default(1) // For weighted random selection (higher = more likely)
  addedBy     String? // Track who added it
  lastChecked DateTime? // For future health checking
  clickCount  Int       @default(0) // Track popularity
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([active])
  @@index([tags])
  @@index([weight])
}

model Media {
  id            String         @id @default(cuid())
  userId        String
  caption       String?
  title         String?
  thumbnailUrl  String
  mediumUrl     String
  fullUrl       String
  originalName  String?
  fileSize      Int?
  mimeType      String?
  mediaType     String         @default("image")
  width         Int?
  height        Int?
  featured      Boolean        @default(false)
  featuredOrder Int?
  visibility    Visibility     @default(public)
  uploadContext UploadContext  @default(media_collection)
  isGalleryItem Boolean        @default(true)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  comments      PhotoComment[]

  @@index([userId, featured, featuredOrder])
  @@index([userId, createdAt])
  @@index([userId, visibility])
  @@index([userId, isGalleryItem])
}

model PhotoComment {
  id        String         @id @default(cuid())
  content   String
  createdAt DateTime       @default(now())
  mediaId   String
  authorId  String
  parentId  String?
  status    CommentStatus  @default(visible)
  author    User           @relation("PhotoCommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  media     Media          @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  parent    PhotoComment?  @relation("PhotoCommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   PhotoComment[] @relation("PhotoCommentReplies")

  @@index([mediaId, createdAt])
  @@index([authorId, createdAt])
  @@index([parentId])
}

model ThreadRing {
  id                    String               @id @default(cuid())
  uri                   String               @unique
  curatorId             String
  name                  String
  slug                  String               @unique
  description           String?
  joinType              ThreadRingJoinType   @default(open)
  visibility            ThreadRingVisibility @default(public)
  memberCount           Int                  @default(1)
  postCount             Int                  @default(0)
  currentPrompt         String?
  curatorNote           String?
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
  directChildrenCount   Int                  @default(0)
  isSystemRing          Boolean              @default(false)
  lineageDepth          Int                  @default(0)
  lineagePath           String               @default("")
  parentId              String?
  totalDescendantsCount Int                  @default(0)
  posts                 PostThreadRing[]
  curator               User                 @relation("ThreadRingCurator", fields: [curatorId], references: [id], onDelete: Cascade)
  parent                ThreadRing?          @relation("ThreadRingHierarchy", fields: [parentId], references: [id])
  children              ThreadRing[]         @relation("ThreadRingHierarchy")
  badge                 ThreadRingBadge?
  blocks                ThreadRingBlock[]    @relation("ThreadRingBlocks")
  userBlocks            UserBlock[]          @relation("UserBlockedThreadRings")
  childFork             ThreadRingFork?      @relation("ThreadRingChild")
  parentForks           ThreadRingFork[]     @relation("ThreadRingParent")
  invites               ThreadRingInvite[]
  members               ThreadRingMember[]

  @@index([curatorId])
  @@index([slug])
  @@index([uri])
  @@index([visibility, joinType])
  @@index([memberCount, postCount])
  @@index([parentId])
  @@index([lineageDepth])
  @@index([isSystemRing])
}

model ThreadRingMember {
  id           String         @id @default(cuid())
  threadRingId String
  userId       String
  role         ThreadRingRole @default(member)
  joinedAt     DateTime       @default(now())
  threadRing   ThreadRing     @relation(fields: [threadRingId], references: [id], onDelete: Cascade)
  user         User           @relation("ThreadRingMemberships", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([threadRingId, userId])
  @@index([userId])
  @@index([threadRingId, role])
}

model PostThreadRing {
  id           String     @id @default(cuid())
  postId       String
  threadRingId String
  addedAt      DateTime   @default(now())
  addedBy      String
  isPinned     Boolean    @default(false)
  pinnedAt     DateTime?
  pinnedBy     String?
  addedByUser  User       @relation("PostThreadRingAdditions", fields: [addedBy], references: [id], onDelete: Cascade)
  post         Post       @relation("PostThreadRings", fields: [postId], references: [id], onDelete: Cascade)
  threadRing   ThreadRing @relation(fields: [threadRingId], references: [id], onDelete: Cascade)

  @@unique([postId, threadRingId])
  @@index([threadRingId, addedAt])
  @@index([threadRingId, isPinned, pinnedAt])
  @@index([postId])
}

model ThreadRingInvite {
  id           String                 @id @default(cuid())
  threadRingId String
  inviterId    String
  inviteeId    String
  status       ThreadRingInviteStatus @default(pending)
  createdAt    DateTime               @default(now())
  respondedAt  DateTime?
  invitee      User                   @relation("ThreadRingInvitationsReceived", fields: [inviteeId], references: [id], onDelete: Cascade)
  inviter      User                   @relation("ThreadRingInvitationsSent", fields: [inviterId], references: [id], onDelete: Cascade)
  threadRing   ThreadRing             @relation(fields: [threadRingId], references: [id], onDelete: Cascade)

  @@unique([threadRingId, inviteeId])
  @@index([inviteeId, status])
  @@index([threadRingId])
}

model ThreadRingFork {
  id            String     @id @default(cuid())
  parentId      String
  childId       String     @unique
  createdBy     String
  forkReason    String?
  createdAt     DateTime   @default(now())
  child         ThreadRing @relation("ThreadRingChild", fields: [childId], references: [id], onDelete: Cascade)
  createdByUser User       @relation("ThreadRingForks", fields: [createdBy], references: [id], onDelete: Cascade)
  parent        ThreadRing @relation("ThreadRingParent", fields: [parentId], references: [id], onDelete: Cascade)

  @@index([parentId])
  @@index([createdBy])
}

model ThreadRingBadge {
  id              String     @id @default(cuid())
  threadRingId    String     @unique
  title           String
  subtitle        String?
  imageUrl        String?
  templateId      String?
  backgroundColor String     @default("#4A90E2")
  textColor       String     @default("#FFFFFF")
  isGenerated     Boolean    @default(true)
  isActive        Boolean    @default(true)
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  threadRing      ThreadRing @relation(fields: [threadRingId], references: [id], onDelete: Cascade)

  @@index([threadRingId])
  @@index([isActive])
}

model ThreadRingBlock {
  id              String              @id @default(cuid())
  threadRingId    String
  blockedUserId   String?
  blockedInstance String?
  blockedActorUri String?
  blockType       ThreadRingBlockType
  reason          String?
  createdBy       String
  createdAt       DateTime            @default(now())
  blockedUser     User?               @relation("ThreadRingBlockedUsers", fields: [blockedUserId], references: [id], onDelete: Cascade)
  createdByUser   User                @relation("ThreadRingBlockCreators", fields: [createdBy], references: [id], onDelete: Cascade)
  threadRing      ThreadRing          @relation("ThreadRingBlocks", fields: [threadRingId], references: [id], onDelete: Cascade)

  @@unique([threadRingId, blockedUserId])
  @@unique([threadRingId, blockedInstance])
  @@unique([threadRingId, blockedActorUri])
  @@index([threadRingId, blockType])
  @@index([blockedUserId])
  @@index([blockedInstance])
  @@index([createdBy])
}

model RingHubOwnership {
  id          String   @id @default(cuid())
  ringSlug    String   @unique
  ringUri     String
  ownerUserId String
  serverDID   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  owner       User     @relation("RingHubOwnerships", fields: [ownerUserId], references: [id], onDelete: Cascade)

  @@index([ownerUserId])
  @@index([serverDID])
}

model UserReport {
  id             String       @id @default(cuid())
  reporterId     String
  reportedUserId String?
  reportType     ReportType
  targetId       String // ID of the reported content (post, comment, etc.)
  reason         ReportReason
  customReason   String?
  description    String?
  status         ReportStatus @default(pending)
  reviewedBy     String?
  reviewedAt     DateTime?
  resolution     String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  reporter       User         @relation("UserReportsCreated", fields: [reporterId], references: [id], onDelete: Cascade)
  reportedUser   User?        @relation("UserReportsReceived", fields: [reportedUserId], references: [id], onDelete: Cascade)
  reviewer       User?        @relation("UserReportsReviewed", fields: [reviewedBy], references: [id], onDelete: SetNull)

  @@index([reporterId])
  @@index([reportedUserId])
  @@index([status, createdAt])
  @@index([targetId, reportType])
  @@index([reviewedBy])
}

model UserBlock {
  id                  String      @id @default(cuid())
  blockerId           String
  blockedUserId       String?
  blockedThreadRingId String?
  reason              String?
  createdAt           DateTime    @default(now())
  blocker             User        @relation("UserBlocksCreated", fields: [blockerId], references: [id], onDelete: Cascade)
  blockedUser         User?       @relation("UserBlocksReceived", fields: [blockedUserId], references: [id], onDelete: Cascade)
  blockedThreadRing   ThreadRing? @relation("UserBlockedThreadRings", fields: [blockedThreadRingId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedUserId])
  @@unique([blockerId, blockedThreadRingId])
  @@index([blockerId])
  @@index([blockedUserId])
  @@index([blockedThreadRingId])
}

enum Visibility {
  public
  followers
  friends
  private
}

enum TemplateMode {
  default
  enhanced
  advanced
}

enum UserRole {
  member
  admin
}

enum AuthMethod {
  SEED_PHRASE // Traditional seed phrase auth (current users)
  PASSWORD // Password-based auth with encrypted seed
}

enum PostIntent {
  sharing
  asking
  feeling
  announcing
  showing
  teaching
  looking
  celebrating
  recommending
}

enum CommentStatus {
  visible
  hidden
}

enum EmailTokenType {
  login
  verification
}

enum NotificationType {
  comment
  reply
  follow
  friend
  guestbook
  photo_comment
  photo_reply
  threadring_invite
  threadring_join
  threadring_post
  threadring_fork
}

enum UploadContext {
  media_collection // Intentional gallery uploads with captions/titles
  post_embed // Images embedded in posts
  profile_photo // Profile/avatar photos
  threadring_badge // ThreadRing badge images
  other // Other contexts
}

enum NotificationStatus {
  unread
  read
  dismissed
}

enum ThreadRingJoinType {
  open
  invite
  closed
}

enum ThreadRingVisibility {
  public
  unlisted
  private
}

enum ThreadRingRole {
  member
  moderator
  curator
}

enum ThreadRingInviteStatus {
  pending
  accepted
  declined
  revoked
}

enum BadgeTemplate {
  classic_blue
  retro_green
  sunset_orange
  midnight_purple
  matrix_green
  neon_pink
  vintage_brown
  cyber_teal
}

enum ThreadRingBlockType {
  user
  instance
  actor
}

enum ReportType {
  user
  post
  comment
  threadring
  guestbook_entry
  photo_comment
}

enum ReportStatus {
  pending
  reviewed
  resolved
  dismissed
}

enum ReportReason {
  spam
  harassment
  hate_speech
  violence
  misinformation
  sexual_content
  copyright
  other
}

model Emoji {
  id        String   @id @default(cuid())
  name      String   @unique
  imageUrl  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String
  creator   User     @relation("EmojiCreator", fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([name])
  @@index([createdBy])
}

model SiteNews {
  id          String       @id @default(cuid())
  title       String
  summary     String
  content     String? // Optional full content for dedicated news pages
  url         String? // Optional custom URL, defaults to /news/{id}
  publishedAt DateTime     @default(now())
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  type        NewsType     @default(announcement)
  priority    NewsPriority @default(medium)
  isPublished Boolean      @default(true)
  createdBy   String
  author      User         @relation("SiteNewsAuthor", fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([publishedAt])
  @@index([type])
  @@index([priority])
  @@index([isPublished])
  @@index([createdBy])
}

enum NewsType {
  announcement
  feature
  maintenance
  community
}

enum NewsPriority {
  high
  medium
  low
}

model BetaLandingPage {
  id           String    @id @default(cuid())
  name         String // Admin-friendly name (e.g., "Twitter Campaign", "Reddit Launch")
  slug         String    @unique // URL slug for the landing page
  title        String // Page title shown to users
  description  String? // Optional description/subtitle
  content      String? // Optional custom HTML content
  isActive     Boolean   @default(true)
  isPaused     Boolean   @default(false) // Temporarily disable without deleting
  signupLimit  Int       @default(50) // Max signups allowed
  signupCount  Int       @default(0) // Current signup count (tracked automatically)
  limitReached Boolean   @default(false) // Computed field for quick checks
  endedAt      DateTime? // When campaign was manually ended
  endedBy      String? // Admin who ended the campaign
  createdBy    String // Admin who created it
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  creator  User                @relation("BetaLandingPagesCreated", fields: [createdBy], references: [id], onDelete: Cascade)
  ender    User?               @relation("BetaLandingPagesEnded", fields: [endedBy], references: [id], onDelete: SetNull)
  signups  BetaLandingSignup[] @relation("BetaLandingPageSignups")
  attempts SignupAttempt[]     @relation("BetaLandingPageAttempts")

  @@index([slug])
  @@index([isActive, isPaused])
  @@index([createdBy])
  @@index([limitReached])
}

model BetaLandingSignup {
  id                String           @id @default(cuid())
  landingPageId     String
  userId            String? // Set when signup completes
  betaCode          String? // Which beta code was used
  signupStartedAt   DateTime         @default(now())
  signupCompletedAt DateTime?
  ipAddress         String? // For analytics
  userAgent         String? // For analytics
  status            BetaSignupStatus @default(started)

  landingPage BetaLandingPage @relation("BetaLandingPageSignups", fields: [landingPageId], references: [id], onDelete: Cascade)
  user        User?           @relation("BetaLandingSignups", fields: [userId], references: [id], onDelete: SetNull)

  @@index([landingPageId, status])
  @@index([userId])
  @@index([ipAddress, signupStartedAt])
}

model IpSignupTracking {
  id                String    @id @default(cuid())
  ipAddress         String    @unique
  signupAttempts    Int       @default(1)
  successfulSignups Int       @default(0)
  firstAttemptAt    DateTime  @default(now())
  lastAttemptAt     DateTime  @default(now())
  isBlocked         Boolean   @default(false)
  blockedAt         DateTime?
  blockedBy         String?
  blockedReason     String?
  autoBlocked       Boolean   @default(false) // Whether block was automatic
  unblockAt         DateTime? // When auto-block expires

  blocker User? @relation("IpBlocksCreated", fields: [blockedBy], references: [id], onDelete: SetNull)

  @@index([ipAddress])
  @@index([isBlocked])
  @@index([lastAttemptAt])
  @@index([autoBlocked, unblockAt])
}

model SignupAttempt {
  id            String   @id @default(cuid())
  ipAddress     String
  userAgent     String?
  landingPageId String?
  betaCode      String?
  attemptedAt   DateTime @default(now())
  success       Boolean  @default(false)
  failureReason String?
  userId        String? // Set if signup succeeded
  suspicious    Boolean  @default(false) // Flagged by detection algorithms

  landingPage BetaLandingPage? @relation("BetaLandingPageAttempts", fields: [landingPageId], references: [id], onDelete: SetNull)
  user        User?            @relation("SignupAttempts", fields: [userId], references: [id], onDelete: SetNull)

  @@index([ipAddress, attemptedAt])
  @@index([landingPageId, attemptedAt])
  @@index([success])
  @@index([suspicious])
}

enum BetaSignupStatus {
  started // User clicked the landing page
  completed // User finished account creation
  abandoned // User started but didn't complete (tracked after timeout)
}

model BetaInviteShare {
  id          String   @id @default(cuid())
  codeId      String // Which beta invite code was shared
  sharedBy    String // User who shared the code
  shareMethod String // How it was shared: "copy_link", "copy_code", "social_share"
  sharedAt    DateTime @default(now())
  ipAddress   String? // IP of the person sharing
  userAgent   String? // Browser info
  referrer    String? // Where they shared from
  platform    String? // Social platform if applicable

  code   BetaInviteCode @relation(fields: [codeId], references: [id], onDelete: Cascade)
  sharer User           @relation("BetaInviteShares", fields: [sharedBy], references: [id], onDelete: Cascade)

  @@index([codeId, sharedAt])
  @@index([sharedBy, sharedAt])
  @@index([shareMethod])
}

model UserConsent {
  id          String      @id @default(cuid())
  userId      String
  type        ConsentType
  granted     Boolean
  timestamp   DateTime    @default(now())
  ipAddress   String?
  userAgent   String?
  withdrawnAt DateTime?
  version     String      @default("1.0") // Track consent policy version

  user User @relation("UserConsents", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type]) // One consent record per type per user (latest)
  @@index([userId, type])
  @@index([granted, timestamp])
}

// Community Index Models
model IndexedSite {
  id          String  @id @default(cuid())
  url         String  @unique
  title       String
  description String?

  // Discovery metadata
  submittedBy      String? // User ID who submitted
  discoveredAt     DateTime @default(now())
  discoveryMethod  String   @default("manual") // search, webring, link, manual, api_seeding
  discoveryContext String? // source URL or context

  // Content analysis
  contentSample     String? // First ~500 chars of content
  extractedKeywords String[] @default([])
  detectedLanguage  String? // ISO 2-letter code
  siteType          String? // blog, portfolio, project, etc.

  // Technical metadata
  lastCrawled    DateTime?
  crawlStatus    String    @default("pending") // success, failed, pending, blocked
  contentHash    String? // Detect content changes
  sslEnabled     Boolean?
  responseTimeMs Int?
  lastModified   DateTime?

  // Community curation
  communityScore Int     @default(0)
  totalVotes     Int     @default(0)
  verifiedBy     String? // Moderator verification user ID
  featured       Boolean @default(false)

  // Seeding specific fields
  seedingScore       Int? // Auto-evaluation score 0-100
  seedingReasons     String[] @default([]) // Why this was seeded
  communityValidated Boolean  @default(false)
  validationVotes    Int      @default(0)

  // Auto-validation fields (Phase 2)
  autoValidated       Boolean? // Was this auto-validated by system?
  autoValidatedAt     DateTime? // When was it auto-validated?
  autoValidationScore Int? // Final score used for auto-validation

  // Corporate profile filtering fields
  indexingPurpose     String?  @default("full_index") // full_index, link_extraction, pending_review, rejected
  platformType        String?  @default("unknown") // independent, indie_platform, corporate_profile, unknown
  extractedLinks      String[] @default([]) // Links extracted from corporate profiles
  extractionCompleted Boolean  @default(false) // Has link extraction been completed?
  parentProfileUrl    String? // URL of corporate profile this was discovered from

  // Connectivity
  outboundLinks String[] @default([]) // Sites this links to
  inboundLinks  String[] @default([]) // Sites linking to this

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  submitter           User?                         @relation("IndexedSiteSubmissions", fields: [submittedBy], references: [id], onDelete: SetNull)
  verifier            User?                         @relation("IndexedSiteVerifications", fields: [verifiedBy], references: [id], onDelete: SetNull)
  votes               SiteVote[]
  tags                SiteTag[]
  reviews             SiteReview[]
  bookmarkSubmissions BookmarkCommunitySubmission[] @relation("BookmarkIndexedSites")

  @@index([url])
  @@index([discoveryMethod])
  @@index([crawlStatus])
  @@index([communityScore])
  @@index([communityValidated])
  @@index([seedingScore])
  @@index([featured])
  @@index([siteType])
  @@index([submittedBy])
  @@index([verifiedBy])
}

model SiteVote {
  id        String   @id @default(cuid())
  siteId    String
  userId    String
  voteType  String // upvote, quality, interesting, helpful, creative, broken, spam
  comment   String?
  createdAt DateTime @default(now())

  site IndexedSite @relation(fields: [siteId], references: [id], onDelete: Cascade)
  user User        @relation("SiteVotes", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([siteId, userId, voteType])
  @@index([siteId])
  @@index([userId])
  @@index([voteType])
}

model SiteTag {
  id          String   @id @default(cuid())
  siteId      String
  tag         String
  suggestedBy String
  votes       Int      @default(1)
  createdAt   DateTime @default(now())

  site      IndexedSite @relation(fields: [siteId], references: [id], onDelete: Cascade)
  suggester User        @relation("SiteTagSuggestions", fields: [suggestedBy], references: [id], onDelete: Cascade)

  @@unique([siteId, tag])
  @@index([siteId])
  @@index([tag])
  @@index([suggestedBy])
}

model DiscoveryPath {
  id              String   @id @default(cuid())
  fromSite        String? // URL or "search" or "surprise"
  toSite          String // URL from IndexedSite
  discoveredBy    String // User ID
  discoveryMethod String // link_click, search_result, webring, random
  sessionId       String?
  createdAt       DateTime @default(now())

  discoverer User @relation("DiscoveryPaths", fields: [discoveredBy], references: [id], onDelete: Cascade)

  @@index([toSite])
  @@index([discoveredBy])
  @@index([discoveryMethod])
  @@index([sessionId])
  @@index([createdAt])
}

model SiteRelationship {
  id               String   @id @default(cuid())
  siteA            String // URL
  siteB            String // URL
  relationshipType String // links_to, same_author, webring_member, similar_content
  strength         Int      @default(1) // How many people discovered this connection
  discoveredBy     String[] @default([]) // User IDs who found this relationship
  createdAt        DateTime @default(now())

  @@unique([siteA, siteB, relationshipType])
  @@index([siteA])
  @@index([siteB])
  @@index([relationshipType])
}

model CrawlQueue {
  id           String    @id @default(cuid())
  url          String
  priority     Int       @default(1) // 1=low, 5=high
  scheduledFor DateTime  @default(now())
  attempts     Int       @default(0)
  lastAttempt  DateTime?
  status       String    @default("pending") // pending, processing, completed, failed
  errorMessage String?
  createdAt    DateTime  @default(now())

  @@index([status, scheduledFor])
  @@index([priority, scheduledFor])
  @@index([url])
}

model DiscoveryLink {
  id             String   @id @default(cuid())
  sourceUrl      String // Corporate profile URL
  sourcePlatform String // youtube, twitter, etc.
  targetUrl      String // Discovered indie site
  linkLocation   String // Where link was found (bio, description, etc.)
  discoveredAt   DateTime @default(now())
  confidence     Float    @default(0.5) // How confident we are this is their site
  processed      Boolean  @default(false) // Has this been added to crawl queue?

  @@index([sourceUrl])
  @@index([targetUrl])
  @@index([sourcePlatform])
  @@index([processed])
}

model DiscoveredSite {
  id          String  @id @default(cuid())
  url         String  @unique
  title       String
  description String?

  // Discovery metadata
  discoveredAt     DateTime @default(now())
  discoveryMethod  String   @default("crawler_auto_submit")
  discoveryContext String?
  discoveredFrom   String? // URL that linked to this site

  // Quality assessment
  qualityScore      Int
  qualityReasons    String[]
  suggestedCategory String?

  // Content analysis
  contentSample     String?
  extractedKeywords String[]  @default([])
  detectedLanguage  String?
  lastCrawled       DateTime?
  crawlStatus       String    @default("success")
  contentHash       String?
  sslEnabled        Boolean?
  responseTimeMs    Int?
  outboundLinks     String[]  @default([])

  // Review status
  reviewStatus String    @default("pending") // pending, approved, rejected, needs_review
  reviewedBy   String? // User ID who reviewed
  reviewedAt   DateTime?
  reviewNotes  String?

  // Promotion to main index
  promotedToIndex Boolean   @default(false)
  promotedAt      DateTime?
  indexedSiteId   String? // Reference to IndexedSite if promoted

  @@index([reviewStatus, qualityScore])
  @@index([discoveredAt])
  @@index([qualityScore(sort: Desc)])
}

model SiteReview {
  id        String   @id @default(cuid())
  siteId    String
  userId    String
  title     String?
  content   String
  rating    Int? // 1-5 star rating (optional)
  helpful   Int      @default(0) // How many found this review helpful
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  site IndexedSite @relation(fields: [siteId], references: [id], onDelete: Cascade)
  user User        @relation("SiteReviews", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([siteId, userId]) // One review per user per site
  @@index([siteId])
  @@index([userId])
  @@index([helpful])
  @@index([rating])
}

model ConsentLog {
  id        String        @id @default(cuid())
  userId    String
  type      ConsentType
  action    ConsentAction
  granted   Boolean? // null for withdrawal actions
  timestamp DateTime      @default(now())
  ipAddress String?
  userAgent String?
  version   String        @default("1.0")

  user User @relation("ConsentLogs", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, timestamp])
  @@index([type, action])
}

enum ConsentType {
  ESSENTIAL // Essential cookies/functionality
  ANALYTICS // Analytics and performance tracking
  MARKETING // Marketing and advertising
  PREFERENCES // User preferences and settings
}

enum ConsentAction {
  GRANTED // User explicitly granted consent
  WITHDRAWN // User explicitly withdrew consent
  UPDATED // User updated existing consent
  EXPIRED // Consent expired due to time limit
}

// Universal Save System Models

enum BookmarkSourceType {
  community_index
  site_content
  external_search
  manual
}

enum CollectionVisibility {
  private
  public
  shared
}

enum BookmarkSubmissionReason {
  user_bookmark
  multiple_bookmarks
  high_engagement
}

enum BookmarkSubmissionStatus {
  pending
  validated
  rejected
  duplicate
}

model UserCollection {
  id          String               @id @default(cuid())
  userId      String
  name        String
  description String?
  visibility  CollectionVisibility @default(private)
  isDefault   Boolean              @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user      User           @relation("UserCollections", fields: [userId], references: [id], onDelete: Cascade)
  bookmarks UserBookmark[] @relation("CollectionBookmarks")

  @@unique([userId, name])
}

model UserBookmark {
  id           String  @id @default(cuid())
  userId       String
  collectionId String? // NULL = default collection

  // Universal fields for any saved item
  url         String
  title       String
  description String?
  faviconUrl  String?

  // Source tracking
  sourceType     BookmarkSourceType
  sourceMetadata Json? // Engine info, search query, content type, etc.

  // Organization
  tags  String[] @default([])
  notes String? // User's personal notes

  // Engagement tracking
  visitsCount   Int       @default(0)
  lastVisitedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                User                         @relation("UserBookmarks", fields: [userId], references: [id], onDelete: Cascade)
  collection          UserCollection?              @relation("CollectionBookmarks", fields: [collectionId], references: [id], onDelete: SetNull)
  communitySubmission BookmarkCommunitySubmission? @relation("BookmarkSubmissions")

  @@unique([userId, url])
}

model BookmarkCommunitySubmission {
  id            String  @id @default(cuid())
  bookmarkId    String  @unique
  indexedSiteId String? // NULL until validated and indexed

  // Auto-submission details
  submissionReason BookmarkSubmissionReason
  submissionScore  Int                      @default(0) // Based on user reputation, engagement, etc.

  status      BookmarkSubmissionStatus @default(pending)
  validatedAt DateTime?
  validatedBy String?

  createdAt DateTime @default(now())

  // Relations
  bookmark    UserBookmark @relation("BookmarkSubmissions", fields: [bookmarkId], references: [id], onDelete: Cascade)
  indexedSite IndexedSite? @relation("BookmarkIndexedSites", fields: [indexedSiteId], references: [id], onDelete: SetNull)
  validator   User?        @relation("BookmarkValidations", fields: [validatedBy], references: [id], onDelete: SetNull)
}

// ========================================
// DECORATION MANAGEMENT SYSTEM
// ========================================

model DecorationItem {
  id       String @id @default(cuid())
  itemId   String @unique // roses_red, stone_path, etc.
  name     String // "Red Roses"
  type     String // plant, furniture, etc.
  category String // plants, paths, etc.
  zone     String // front_yard, house_facade, etc.

  // Visual assets
  iconSvg   String? // SVG code for palette icon
  renderSvg String? // SVG code for canvas rendering
  imagePath String? // Path to uploaded image asset

  // Grid behavior
  gridWidth  Int @default(1)
  gridHeight Int @default(1)

  // Availability control
  isActive    Boolean     @default(true)
  releaseType ReleaseType @default(PUBLIC)

  // Limited-time releases
  releaseStartAt DateTime?
  releaseEndAt   DateTime?
  claimCode      String?   @unique // Special code for limited releases
  maxClaims      Int? // Max users who can claim
  claimCount     Int       @default(0)

  // Metadata
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String? // Admin user ID (optional for system items)

  // Relations
  creator    User?                 @relation("DecorationItemsCreated", fields: [createdBy], references: [id])
  userClaims UserDecorationClaim[]

  @@index([releaseType])
  @@index([releaseStartAt, releaseEndAt])
  @@index([claimCode])
  @@index([isActive])
  @@index([itemId])
}

model UserDecorationClaim {
  id           String      @id @default(cuid())
  userId       String
  decorationId String
  claimedAt    DateTime    @default(now())
  claimMethod  ClaimMethod @default(DIRECT) // DIRECT, CODE, ADMIN_GRANT

  user       User           @relation("UserDecorationClaims", fields: [userId], references: [id])
  decoration DecorationItem @relation(fields: [decorationId], references: [id], onDelete: Cascade)

  @@unique([userId, decorationId])
  @@index([userId])
  @@index([decorationId])
}

enum ReleaseType {
  DEFAULT // Always available to everyone, no claiming needed
  PUBLIC // Available to all users (can track claims)
  LIMITED_TIME // Available during specific timeframe
  CLAIM_CODE // Requires special code to unlock
  ADMIN_ONLY // Only admin can grant access
  BETA_USERS // Only beta users
}

enum ClaimMethod {
  DIRECT // Standard public access
  CODE // Claimed via special code
  ADMIN_GRANT // Manually granted by admin
  BETA_ACCESS // Access via beta status
}
